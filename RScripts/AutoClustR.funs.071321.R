Proc.data <- function(data, algorithm = "seurat", expr.meas = "umi", n.features = 2000, seed = NULL){

  # library(cidr)
  # library(Rtsne)
  # library(Seurat)
  # library(SingleCellExperiment)

  if(algorithm == "cidr"){

    if(expr.meas == "umi"){
      expr.meas <- "raw"
    }
    
    object <- scDataConstructor(tags = counts(data), tagType = expr.meas)
    scData.wLabs <- setClass("scData.wLabs", slots = c(labels = "vector"), contains = "scData")
    object <- as(object = object, Class = "scData.wLabs")
    object@labels <- colData(data)$labels
    
    object <- determineDropoutCandidates(object = object) %>%
      wThreshold() %>%
      scDissim() %>%
      scPCA(plotPC = FALSE)

  }else if (algorithm %in% c("seurat", "IKAP") ){

    object <- CreateSeuratObject(counts = counts(data))
    object@meta.data$labels <- colData(data)$labels
    object@meta.data$n.features <- colData(data)$n.features
    object@meta.data$pct.mito <- object@meta.data$percent.mito <- colData(data)$pct.mito
    object@meta.data$nUMI <- object@meta.data$nCount_RNA
    
    if (algorithm == "seurat") {
      if(expr.meas == "umi"){
        
        object <- NormalizeData(object = object, scale.factor = 1e6) %>%
          FindVariableFeatures() %>%
          ScaleData(vars.to.regress = c("pct.mito", "n.features")) 
        
      }else if(expr.meas == "tpm" | expr.meas == "cpm"){
        
        object@assays$RNA <- CreateAssayObject(data = log1p(counts(data)))
        object <- FindVariableFeatures(object = object, selection.method = "mvp") %>%
          ScaleData(vars.to.regress = c("pct.mito", "n.features"))
        
      }
      
      object <- RunPCA(object = object, seed.use = seed)
      
    } else if (algorithm == "IKAP") {
      if(expr.meas == "umi"){
        
        object <- NormalizeData(object = object, scale.factor = 1e6)
        
      }else if(expr.meas == "tpm" | expr.meas == "cpm"){
        
        object@assays$RNA <- CreateAssayObject(data = log1p(counts(data)))
        
      }
    }
    
  }else if(algorithm == "tsne-kmeans"){

    object <- data
    
    if(expression.measure == "umi"){
      logcounts(object) <- log1p(1e6 * proportions(counts(object), margin = 2))
    }else if(expr.meas == "tpm" | expr.meas == "cpm"){
      logcounts(object) <- log1p(counts(object))
    }
    
    model.summary.table <- modelGeneVar(object)
    model.summary.table <- model.summary.table[order(model.summary.table[, 4], decreasing = TRUE), ]
    variable.features <- rownames(model.summary.table)[1:n.features]
    object <- object[variable.features, ]
    
    pca.results <- prcomp(t(logcounts(object)), scale. = TRUE)
    reducedDim(object, type = "pca") <- pca.results$x
    metadata(object)$roots <- pca.results$sdev

  }

  return(value = object)
}

ClustR <- function(object = object,
                   algorithm = "seurat",
                   n.pcs = 10,
                   nCluster = NULL,
                   k.param = NULL,
                   resolution= NULL,
                   centers = 10,
                   perplexity = 30,
                   seed = 0){
  
  if(class(object) == "scData" | class(object) == "scData.wLabs"){
    
    object <- scCluster(object = object, nCluster = nCluster, nPC = n.pcs)
    
    comp.scores <- object@PC[, 1:n.pcs]
    clusters <- object@clusters
    
  } else if(class(object) == "Seurat"){
    
    object <- FindNeighbors(object = object, dims = 1:n.pcs, k.param = k.param, prune.SNN = 1/15)
      
    object <- FindClusters(object = object, resolution = resolution, random.seed = 534555234)
    
    projections <- Embeddings(object = object)[, 1:n.pcs]
    clusters <- as.integer(Idents(object))
    
  } else if(class(object) == "SingleCellExperiment"){
    
    reducedDim(object, type = "tsne") <- Rtsne(reducedDim(object, type = "pca")[, 1:n.pcs], perplexity = perplexity, pca = FALSE)$Y
    colData(object)$clusters <- kmeans(reducedDim(object, type = "tsne"), centers = centers)$cluster
    
    projections <- reducedDim(object)[, 1:n.pcs]
    clusters <- as.integer(colData(object)$clusters)
    
  }
  
  # TODO: User should be able to select from whichever ICVI they choose
  ICVI <- index.S(d = dist(projections, method = "manhattan"), cl = clusters)
  
  if(!is.finite(ICVI)){
    ICVI <- -1
  }
  
  return(value = list(Score = ICVI))
}

Comp.ICVI <- function(object, clusters, dim){
  
  # library(aricode)
  # library(clusterSim)
  # library(clValid)
  # library(fpc)
  # library(SingleCellExperiment)
  
  if(class(object) == "Seurat"){
    object <- as.SingleCellExperiment(object)
  }
  
  index.list <- c(
    ARI(c1 = colData(object)$labels, c2 = clusters),
    calinhara(reducedDim(object, type = "pca")[, 1:dim], clustering = clusters),
    calinhara(scale(reducedDim(object, type = "pca")[, 1:dim]), clustering = clusters),
    index.DB(reducedDim(object, type = "pca")[, 1:dim], cl = clusters)$DB,
    index.DB(reducedDim(object, type = "pca")[, 1:dim], cl = clusters, p = 1)$DB,
    index.DB(scale(reducedDim(object, type = "pca")[, 1:dim]), cl = clusters)$DB,
    index.DB(scale(reducedDim(object, type = "pca")[, 1:dim]), cl = clusters, p = 1)$DB,
    dunn(clusters = clusters, Data = reducedDim(object, type = "pca")[, 1:dim]),
    dunn(clusters = clusters, Data = reducedDim(object, type = "pca")[, 1:dim], method = "manhattan"),
    dunn(clusters = clusters, Data = scale(reducedDim(object, type = "pca")[, 1:dim])), #scale: set mean to 0, set SD to 1
    dunn(clusters = clusters, Data = scale(reducedDim(object, type = "pca")[, 1:dim]), method = "manhattan"),
    index.S(d = dist(reducedDim(object, type = "pca")[, 1:dim]), cl = clusters),
    index.S(d = dist(reducedDim(object, type = "pca")[, 1:dim], method = "manhattan"), cl = clusters),
    index.S(d = dist(scale(reducedDim(object, type = "pca")[, 1:dim])), cl = clusters),
    index.S(d = dist(scale(reducedDim(object, type = "pca")[, 1:dim]), method = "manhattan"), cl = clusters)
  )
  
  return(index.list)
}

AutoClustR <- function(object,
                       file.path,
                       method = "Bayesian",
                       x.bounds = list(k.param = c(2L, 160L),
                                       resolution= c(0.0, 2.0)),
                       n.priors = 15,
                       n.starts = 15,
                       n.pcs = NULL){
  
  # library(clusterSim)
  # library(lhs)
  # library(lme4)
  # library(ParBayesianOptimization)
  # library(Seurat)
  # library(stringi)
  
  # TODO: Going to have to add some checks to make sure input (i.e., x.bounds)
  #       is properly formatted. This is probably the most delicate part
  
  if(is.null(n.pcs)){
    if(class(object) == "scData"){
      roots <- object@variation
    }else if(class(object) == "Seurat"){
      roots <- object@reductions[["pca"]]@stdev
    }else if(class(object) == "SingleCellExperiment"){
      roots <- metadata(object)$roots
    }
    n.pcs <- Select.nPC(roots, file.path = file.path, do.plot = F)
  }
  
  n.pcs <- n.pcs[[2]]

  if(method == "Bayesian"){
    
    output <- ParBayesianOptimization::bayesOpt(
      FUN = function(...){ 
        ClustR(object = object, n.pcs = n.pcs, ...)
        },
      iters.n = n.starts - 1, 
      initPoints = n.priors, 
      bounds = x.bounds
      )
    
    x.best <- getBestPars(output)
    
  }else if(method == "Nelder-Mead"){
    
    x.mins <- sapply(x.bounds, "[", 1)
    x.maxes <- sapply(x.bounds, "[", 2)
    
    x0 <- maximinLHS(n = n.starts, k = length(x.bounds))
    
    for(i in 1:ncol(x0)){
      x0[, i] <- x0[, i] * (x.maxes[[i]] - x.mins[[i]]) + x.mins[[i]]
    }
    
    y.list <- list()
    x.list <- list()
    
    for(i in 1:n.starts){
      
      output <- Nelder_Mead(
        fn = function(x){
          eval(parse(text = paste0("do.call(ClustR, list(object = object, n.pcs = n.pcs, ", stri_join(names(x.bounds), stri_join("x[[", 1:length(x.bounds), "]]"), sep='=', collapse=','), "))")))},
        par = x0[i, ], lower = x.mins, upper = x.maxes)

      y.list[[i]] <- output$fval
      x.list[[i]] <- output$par
    }

    x.best <- x.list[[which.max(y.list)]]
        
  }

  
  return(value = list(object, method, n.pcs, x.best, x.bounds))
}
# output <- AutoClustR(object = object, file.path = "C:/Users/15635/Documents/")

#Should be sourcing stuff here, but
# TODO: Add verbosity option to AutoClustR

b1 <- Proc.data(b1)
ACTest <- AutoClustR(b1, file.path = "", method = "Bayesian")
